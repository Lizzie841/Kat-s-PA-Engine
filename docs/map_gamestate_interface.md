## Map-Game State Interface

Given that I (Schombert) haven't been working on the map at all, we need to arrange for a fixed interface (at the moment, just for the raw map data itself) between the map and the rest of the program. In particular, we need to decide on the format for the persistent map data that will be created when the scenario is first loaded.

### Province identifiers

For the main game state, provinces are identified by `dcon::province_id` types. However, this is probably not the most convenient for the map. `dcon::province_id` stores the "not a valid province" state as a -1 index, internally, which is a bit awkward for using as a texture coordinate, etc. Thus, we will have two utility functions in `province.hpp`: `uint16_t to_map_id(dcon::province_id)` and `dcon::province_id from_map_id(uint16_t)`. These will convert the province id type to an unsigned integer where `0` represents the "invalid" province, and all other provinces count sequentially up from there. To get the number of provinces, you can query `state.world.province_size()`. Adding 1 to that will tell you the size of an array or other structure you need to hold all possible values that could be returned from `to_map_id`.

### Map data

At some point in the scenario construction process, the map section should provide a function to call that can load the source map data (i.e. the image files) into an array of bytes. Specifically, the map "module" should provide the following function `void load_map_data(sys::state& state, ankerl::unordered_dense::map<uint32_t, dcon::province_id> const& color_map, error_handler& err)`. The first parameter is just the state object (because you probably need the file system object to be able to open the map images, right?). The second parameter is a map giving the canonical mapping between color values packed as `uint32_t` values and the province id type. To get the necessary `uint32_t` value from the color data, call the `uint32_t sys::pack_color(int32_t r, int32_t g, int32_t b) ` function provided in `container_types.hpp` (technically, packing the values in an int makes it a container, right?). You can use this map with the standard `find()` function, which will return an iterator equal to `color_map.end()` if the color isn't in the map, and if it is in the map you can get the province id out with `returned_iterator->second`.

There are two possibilities for the map. First you should check for the existence of `provinces.png` in the path. If it is there, you should remember that you are loading a "new" map, and read data out of it as if it covered the entire surface of the globe, i.e. as if the topmost row was the north pole and the bottommost was the south pole. If that file is not found, you should instead try to load `provinces.bmp`. In this case, you should figure out an estimate for the top and bottom latitudes (not from the file; just work out an estimate that you will always fall back to in this case). Then, using the vertical size of the file, figure out how many rows would be required if the `bmp` would have been extended to the north and south poles. Then read the data out of the bitmap, except at the beginning of the read fill the top section of the map data with `0` (the invalid province value) until you reach your latitude estimate, then read the file data, and then finally fill in the remaining space until the south pole with `0`s again. **Note**, when rendering, you should just display these `0`s as water, and you should simply discard any ui clicks upon them. The reason that the above procedure is suggested is to that, after the map has been loaded, the same routines can use the map data regardless of whether it came from an old map or a new map (although there may need to be a little special logic for the minimap). The map data, which should be stored internally as a contiguous block of uint16_t map id values, as well as its dimensions and size should be stored somewhere in `sys::state` (where is up to you), and you should record that information somewhere in this document, so that it can be serialized and deserialized correctly later.

Once the map has been loaded, you will also need the terrain map. Conceptually this is the same thing, except that I imagine you will want to store the data as an array of uint8_t values. As with the provinces map, the legacy terrain `bmp`, if it is being used, needs to be filled out with extra data to cover the entire globe. As an added wrinkle, you will need to decide on how you want the `terrain.png` for the "new" map to store the terrain information. Someone (OK, probably me, I know how these things go) will have to create this new terrain image for the new map, so try to make life as easy for this person as you can. As above, you need to decide where to store the data you read in `sys::state` and record that choice so that it can be serialized and deserialized.

**Do not** create any OpenGL assets during this process. The scenario may be created in a situation where OpenGL isn't ready, or where a window isn't even present. That part of the map creation process needs its own function, which I suggest would be most appropriately placed in the platform independent OpenGL initialization function (i.e. where we create the shaders). That OpenGL initialization function will *always* be called *after* the scenario has been created or loaded, and so the map data will be available to you at that point.
